import{N as X,S as v,R as T,P as m,U as C,ap as I,an as Z,ag as _,aM as oo,a8 as no,aK as io,aL as so,aN as H,aO as eo,aP as G,aQ as to,Q as K,ai as Y,aR as y,aS as c,aw as q,aT as z,Y as L,L as S,a5 as R}from"./BQ8AHac6.js";const U=.5,ao=2,g=0,P=1,N=60,W=0,ro=.01,uo=Math.PI*ao;function co(n){const o=n.initialPosition,{dx:i,dy:s}=C(o,n.position),e=Math.abs(i),a=Math.abs(s),{maxDistance:t}=n.retina,u=t.horizontal,r=t.vertical;if(!u&&!r)return;const d=(u&&e>=u)??!1,h=(r&&a>=r)??!1;if((d||h)&&!n.misplaced)n.misplaced=!!u&&e>u||!!r&&a>r,u&&(n.velocity.x=n.velocity.y*U-n.velocity.x),r&&(n.velocity.y=n.velocity.x*U-n.velocity.y);else if((!u||e<u)&&(!r||a<r)&&n.misplaced)n.misplaced=!1;else if(n.misplaced){const l=n.position,f=n.velocity;u&&(l.x<o.x&&f.x<g||l.x>o.x&&f.x>g)&&(f.x*=-m()),r&&(l.y<o.y&&f.y<g||l.y>o.y&&f.y>g)&&(f.y*=-m())}}function fo(n,o,i,s,e,a){yo(n,a);const t=n.gravity,u=t!=null&&t.enable&&t.inverse?-1:P;e&&i&&(n.velocity.x+=e*a.factor/(N*i)),t!=null&&t.enable&&i&&(n.velocity.y+=u*(t.acceleration*a.factor)/(N*i));const r=n.moveDecay;n.velocity.multTo(r);const d=n.velocity.mult(i);t!=null&&t.enable&&s>g&&(!t.inverse&&d.y>=g&&d.y>=s||t.inverse&&d.y<=g&&d.y<=-s)&&(d.y=u*s,i&&(n.velocity.y=d.y/i));const h=n.options.zIndex,l=(P-n.zIndexFactor)**h.velocityRate;d.multTo(l);const{position:f}=n;f.addTo(d),o.vibrate&&(f.x+=Math.sin(f.x*Math.cos(f.y)),f.y+=Math.cos(f.y*Math.sin(f.x)))}function ho(n,o){const i=n.container;if(!n.spin)return;const s=n.spin.direction===T.clockwise,e={x:s?Math.cos:Math.sin,y:s?Math.sin:Math.cos};n.position.x=n.spin.center.x+n.spin.radius*e.x(n.spin.angle),n.position.y=n.spin.center.y+n.spin.radius*e.y(n.spin.angle),n.spin.radius+=n.spin.acceleration;const a=Math.max(i.canvas.size.width,i.canvas.size.height),t=a*U;n.spin.radius>t?(n.spin.radius=t,n.spin.acceleration*=-1):n.spin.radius<W&&(n.spin.radius=W,n.spin.acceleration*=-1),n.spin.angle+=o*ro*(P-n.spin.radius/a)}function yo(n,o){var t;const i=n.options,s=i.move.path;if(!s.enable)return;if(n.lastPathTime<=n.pathDelay){n.lastPathTime+=o.value;return}const a=(t=n.pathGenerator)==null?void 0:t.generate(n,o);a&&n.velocity.addTo(a),s.clamp&&(n.velocity.x=I(n.velocity.x,-1,P),n.velocity.y=I(n.velocity.y,-1,P)),n.lastPathTime-=n.pathDelay}function lo(n){return n.slow.inRange?n.slow.factor:P}function vo(n){const o=n.container,i=n.options,s=i.move.spin;if(!s.enable)return;const e=s.position??{x:50,y:50},a=.01,t={x:e.x*a*o.canvas.size.width,y:e.y*a*o.canvas.size.height},u=n.getPosition(),r=X(u,t),d=v(s.acceleration);n.retina.spinAcceleration=d*o.retina.pixelRatio,n.spin={center:t,direction:n.velocity.x>=g?T.clockwise:T.counterClockwise,angle:m()*uo,radius:r,acceleration:n.retina.spinAcceleration}}const mo=2,go=1,xo=1;class bo{init(o){const i=o.options,s=i.move.gravity;o.gravity={enable:s.enable,acceleration:v(s.acceleration),inverse:s.inverse},vo(o)}isEnabled(o){return!o.destroyed&&o.options.move.enable}move(o,i){var E,B;const s=o.options,e=s.move;if(!e.enable)return;const a=o.container,t=a.retina.pixelRatio;(E=o.retina).moveSpeed??(E.moveSpeed=v(e.speed)*t),(B=o.retina).moveDrift??(B.moveDrift=v(o.options.move.drift)*t);const u=lo(o),r=o.retina.moveSpeed*a.retina.reduceFactor,d=o.retina.moveDrift,h=Z(s.size.value)*t,l=e.size?o.getRadius()/h:go,f=i.factor||xo,$=r*l*u*f/mo,J=o.retina.maxSpeed??a.retina.maxSpeed;e.spin.enable?ho(o,$):fo(o,e,$,J,d,i),co(o)}}async function po(n,o=!0){n.checkVersion("3.8.1"),await n.addMover("base",()=>Promise.resolve(new bo),o)}const wo=2,zo=Math.PI*wo,Mo=0,Q={x:0,y:0};function Po(n){const{context:o,particle:i,radius:s}=n;i.circleRange||(i.circleRange={min:Mo,max:zo});const e=i.circleRange;o.arc(Q.x,Q.y,s,e.min,e.max,!1)}const Co=12,So=360,j=0;class Ro{constructor(){this.validTypes=["circle"]}draw(o){Po(o)}getSidesCount(){return Co}particleInit(o,i){const s=i.shapeData,e=(s==null?void 0:s.angle)??{max:So,min:j};i.circleRange=oo(e)?{min:_(e.min),max:_(e.max)}:{min:j,max:_(e)}}}async function Vo(n,o=!0){n.checkVersion("3.8.1"),await n.addShape(new Ro,o)}class Oo{constructor(o,i){this._container=o,this._engine=i}init(o){const i=no(this._engine,o.options.color,o.id,o.options.reduceDuplicates);i&&(o.color=io(i,o.options.color.animation,this._container.retina.reduceFactor))}isEnabled(o){const{h:i,s,l:e}=o.options.color.animation,{color:a}=o;return!o.destroyed&&!o.spawning&&((a==null?void 0:a.h.value)!==void 0&&i.enable||(a==null?void 0:a.s.value)!==void 0&&s.enable||(a==null?void 0:a.l.value)!==void 0&&e.enable)}update(o,i){so(o.color,i)}}async function ko(n,o=!0){n.checkVersion("3.8.1"),await n.addParticleUpdater("color",i=>Promise.resolve(new Oo(i,n)),o)}var b;(function(n){n[n.r=1]="r",n[n.g=2]="g",n[n.b=3]="b",n[n.a=4]="a"})(b||(b={}));const Do=/^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i,Fo=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i,V=16,Ao=1,_o=255;class To{constructor(){this.key="hex",this.stringPrefix="#"}handleColor(o){return this._parseString(o.value)}handleRangeColor(o){return this._parseString(o.value)}parseString(o){return this._parseString(o)}_parseString(o){if(typeof o!="string"||!(o!=null&&o.startsWith(this.stringPrefix)))return;const i=o.replace(Do,(e,a,t,u,r)=>a+a+t+t+u+u+(r!==void 0?r+r:"")),s=Fo.exec(i);return s?{a:s[b.a]!==void 0?parseInt(s[b.a],V)/_o:Ao,b:parseInt(s[b.b],V),g:parseInt(s[b.g],V),r:parseInt(s[b.r],V)}:void 0}}async function Uo(n,o=!0){n.checkVersion("3.8.1"),await n.addColorManager(new To,o)}var p;(function(n){n[n.h=1]="h",n[n.s=2]="s",n[n.l=3]="l",n[n.a=5]="a"})(p||(p={}));class Lo{constructor(){this.key="hsl",this.stringPrefix="hsl"}handleColor(o){const i=o.value,s=i.hsl??o.value;if(s.h!==void 0&&s.s!==void 0&&s.l!==void 0)return H(s)}handleRangeColor(o){const i=o.value,s=i.hsl??o.value;if(s.h!==void 0&&s.l!==void 0)return H({h:v(s.h),l:v(s.l),s:v(s.s)})}parseString(o){if(!o.startsWith("hsl"))return;const i=/hsla?\(\s*(\d+)\s*[\s,]\s*(\d+)%\s*[\s,]\s*(\d+)%\s*([\s,]\s*(0|1|0?\.\d+|(\d{1,3})%)\s*)?\)/i,s=i.exec(o),e=4,a=1,t=10;return s?eo({a:s.length>e?G(s[p.a]):a,h:parseInt(s[p.h],t),l:parseInt(s[p.l],t),s:parseInt(s[p.s],t)}):void 0}}async function $o(n,o=!0){n.checkVersion("3.8.1"),await n.addColorManager(new Lo,o)}class Eo{constructor(o){this.container=o}init(o){const i=o.options.opacity,s=1;o.opacity=to(i,s);const e=i.animation;e.enable&&(o.opacity.velocity=v(e.speed)/K*this.container.retina.reduceFactor,e.sync||(o.opacity.velocity*=m()))}isEnabled(o){return!o.destroyed&&!o.spawning&&!!o.opacity&&o.opacity.enable&&((o.opacity.maxLoops??0)<=0||(o.opacity.maxLoops??0)>0&&(o.opacity.loops??0)<(o.opacity.maxLoops??0))}reset(o){o.opacity&&(o.opacity.time=0,o.opacity.loops=0)}update(o,i){!this.isEnabled(o)||!o.opacity||Y(o,o.opacity,!0,o.options.opacity.animation.destroy,i)}}async function Bo(n,o=!0){n.checkVersion("3.8.1"),await n.addParticleUpdater("opacity",i=>Promise.resolve(new Eo(i)),o)}const A=0,M=0;function Io(n){if(n.outMode!==y.bounce&&n.outMode!==y.split||n.direction!==c.left&&n.direction!==c.right)return;n.bounds.right<M&&n.direction===c.left?n.particle.position.x=n.size+n.offset.x:n.bounds.left>n.canvasSize.width&&n.direction===c.right&&(n.particle.position.x=n.canvasSize.width-n.size-n.offset.x);const o=n.particle.velocity.x;let i=!1;if(n.direction===c.right&&n.bounds.right>=n.canvasSize.width&&o>A||n.direction===c.left&&n.bounds.left<=M&&o<A){const e=v(n.particle.options.bounce.horizontal.value);n.particle.velocity.x*=-e,i=!0}if(!i)return;const s=n.offset.x+n.size;n.bounds.right>=n.canvasSize.width&&n.direction===c.right?n.particle.position.x=n.canvasSize.width-s:n.bounds.left<=M&&n.direction===c.left&&(n.particle.position.x=s),n.outMode===y.split&&n.particle.destroy()}function Ho(n){if(n.outMode!==y.bounce&&n.outMode!==y.split||n.direction!==c.bottom&&n.direction!==c.top)return;n.bounds.bottom<M&&n.direction===c.top?n.particle.position.y=n.size+n.offset.y:n.bounds.top>n.canvasSize.height&&n.direction===c.bottom&&(n.particle.position.y=n.canvasSize.height-n.size-n.offset.y);const o=n.particle.velocity.y;let i=!1;if(n.direction===c.bottom&&n.bounds.bottom>=n.canvasSize.height&&o>A||n.direction===c.top&&n.bounds.top<=M&&o<A){const e=v(n.particle.options.bounce.vertical.value);n.particle.velocity.y*=-e,i=!0}if(!i)return;const s=n.offset.y+n.size;n.bounds.bottom>=n.canvasSize.height&&n.direction===c.bottom?n.particle.position.y=n.canvasSize.height-s:n.bounds.top<=M&&n.direction===c.top&&(n.particle.position.y=s),n.outMode===y.split&&n.particle.destroy()}class No{constructor(o){this.container=o,this.modes=[y.bounce,y.split]}update(o,i,s,e){if(!this.modes.includes(e))return;const a=this.container;let t=!1;for(const f of a.plugins.values())if(f.particleBounce!==void 0&&(t=f.particleBounce(o,s,i)),t)break;if(t)return;const u=o.getPosition(),r=o.offset,d=o.getRadius(),h=q(u,d),l=a.canvas.size;Io({particle:o,outMode:e,direction:i,bounds:h,canvasSize:l,offset:r,size:d}),Ho({particle:o,outMode:e,direction:i,bounds:h,canvasSize:l,offset:r,size:d})}}const O=0;class Wo{constructor(o){this.container=o,this.modes=[y.destroy]}update(o,i,s,e){if(!this.modes.includes(e))return;const a=this.container;switch(o.outType){case z.normal:case z.outside:if(L(o.position,a.canvas.size,S.origin,o.getRadius(),i))return;break;case z.inside:{const{dx:t,dy:u}=C(o.position,o.moveCenter),{x:r,y:d}=o.velocity;if(r<O&&t>o.moveCenter.radius||d<O&&u>o.moveCenter.radius||r>=O&&t<-o.moveCenter.radius||d>=O&&u<-o.moveCenter.radius)return;break}}a.particles.remove(o,o.group,!0)}}const k=0;class Qo{constructor(o){this.container=o,this.modes=[y.none]}update(o,i,s,e){if(!this.modes.includes(e)||((o.options.move.distance.horizontal&&(i===c.left||i===c.right))??(o.options.move.distance.vertical&&(i===c.top||i===c.bottom))))return;const a=o.options.move.gravity,t=this.container,u=t.canvas.size,r=o.getRadius();if(a.enable){const d=o.position;(!a.inverse&&d.y>u.height+r&&i===c.bottom||a.inverse&&d.y<-r&&i===c.top)&&t.particles.remove(o)}else{if(o.velocity.y>k&&o.position.y<=u.height+r||o.velocity.y<k&&o.position.y>=-r||o.velocity.x>k&&o.position.x<=u.width+r||o.velocity.x<k&&o.position.x>=-r)return;L(o.position,t.canvas.size,S.origin,r,i)||t.particles.remove(o)}}}const D=0,F=0;class jo{constructor(o){this.container=o,this.modes=[y.out]}update(o,i,s,e){if(!this.modes.includes(e))return;const a=this.container;switch(o.outType){case z.inside:{const{x:t,y:u}=o.velocity,r=S.origin;r.length=o.moveCenter.radius,r.angle=o.velocity.angle+Math.PI,r.addTo(S.create(o.moveCenter));const{dx:d,dy:h}=C(o.position,r);if(t<=D&&d>=F||u<=D&&h>=F||t>=D&&d<=F||u>=D&&h<=F)return;o.position.x=Math.floor(R({min:0,max:a.canvas.size.width})),o.position.y=Math.floor(R({min:0,max:a.canvas.size.height}));const{dx:l,dy:f}=C(o.position,o.moveCenter);o.direction=Math.atan2(-f,-l),o.velocity.angle=o.direction;break}default:{if(L(o.position,a.canvas.size,S.origin,o.getRadius(),i))return;switch(o.outType){case z.outside:{o.position.x=Math.floor(R({min:-o.moveCenter.radius,max:o.moveCenter.radius}))+o.moveCenter.x,o.position.y=Math.floor(R({min:-o.moveCenter.radius,max:o.moveCenter.radius}))+o.moveCenter.y;const{dx:t,dy:u}=C(o.position,o.moveCenter);o.moveCenter.radius&&(o.direction=Math.atan2(u,t),o.velocity.angle=o.direction);break}case z.normal:{const t=o.options.move.warp,u=a.canvas.size,r={bottom:u.height+o.getRadius()+o.offset.y,left:-o.getRadius()-o.offset.x,right:u.width+o.getRadius()+o.offset.x,top:-o.getRadius()-o.offset.y},d=o.getRadius(),h=q(o.position,d);i===c.right&&h.left>u.width+o.offset.x?(o.position.x=r.left,o.initialPosition.x=o.position.x,t||(o.position.y=m()*u.height,o.initialPosition.y=o.position.y)):i===c.left&&h.right<-o.offset.x&&(o.position.x=r.right,o.initialPosition.x=o.position.x,t||(o.position.y=m()*u.height,o.initialPosition.y=o.position.y)),i===c.bottom&&h.top>u.height+o.offset.y?(t||(o.position.x=m()*u.width,o.initialPosition.x=o.position.x),o.position.y=r.top,o.initialPosition.y=o.position.y):i===c.top&&h.bottom<-o.offset.y&&(t||(o.position.x=m()*u.width,o.initialPosition.x=o.position.x),o.position.y=r.bottom,o.initialPosition.y=o.position.y);break}}break}}}}const Go=(n,o)=>n.default===o||n.bottom===o||n.left===o||n.right===o||n.top===o;class Ko{constructor(o){this._addUpdaterIfMissing=(i,s,e)=>{const a=i.options.move.outModes;!this.updaters.has(s)&&Go(a,s)&&this.updaters.set(s,e(this.container))},this._updateOutMode=(i,s,e,a)=>{for(const t of this.updaters.values())t.update(i,a,s,e)},this.container=o,this.updaters=new Map}init(o){this._addUpdaterIfMissing(o,y.bounce,i=>new No(i)),this._addUpdaterIfMissing(o,y.out,i=>new jo(i)),this._addUpdaterIfMissing(o,y.destroy,i=>new Wo(i)),this._addUpdaterIfMissing(o,y.none,i=>new Qo(i))}isEnabled(o){return!o.destroyed&&!o.spawning}update(o,i){const s=o.options.move.outModes;this._updateOutMode(o,i,s.bottom??s.default,c.bottom),this._updateOutMode(o,i,s.left??s.default,c.left),this._updateOutMode(o,i,s.right??s.default,c.right),this._updateOutMode(o,i,s.top??s.default,c.top)}}async function Yo(n,o=!0){n.checkVersion("3.8.1"),await n.addParticleUpdater("outModes",i=>Promise.resolve(new Ko(i)),o)}var w;(function(n){n[n.r=1]="r",n[n.g=2]="g",n[n.b=3]="b",n[n.a=5]="a"})(w||(w={}));class qo{constructor(){this.key="rgb",this.stringPrefix="rgb"}handleColor(o){const i=o.value,s=i.rgb??o.value;if(s.r!==void 0)return s}handleRangeColor(o){const i=o.value,s=i.rgb??o.value;if(s.r!==void 0)return{r:v(s.r),g:v(s.g),b:v(s.b)}}parseString(o){if(!o.startsWith(this.stringPrefix))return;const i=/rgba?\(\s*(\d{1,3})\s*[\s,]\s*(\d{1,3})\s*[\s,]\s*(\d{1,3})\s*([\s,]\s*(0|1|0?\.\d+|(\d{1,3})%)\s*)?\)/i,s=i.exec(o),e=10;return s?{a:s.length>4?G(s[w.a]):1,b:parseInt(s[w.b],e),g:parseInt(s[w.g],e),r:parseInt(s[w.r],e)}:void 0}}async function Jo(n,o=!0){n.checkVersion("3.8.1"),await n.addColorManager(new qo,o)}const x=0;class Xo{init(o){const i=o.container,s=o.options.size,e=s.animation;e.enable&&(o.size.velocity=(o.retina.sizeAnimationSpeed??i.retina.sizeAnimationSpeed)/K*i.retina.reduceFactor,e.sync||(o.size.velocity*=m()))}isEnabled(o){return!o.destroyed&&!o.spawning&&o.size.enable&&((o.size.maxLoops??x)<=x||(o.size.maxLoops??x)>x&&(o.size.loops??x)<(o.size.maxLoops??x))}reset(o){o.size.loops=x}update(o,i){this.isEnabled(o)&&Y(o,o.size,!0,o.options.size.animation.destroy,i)}}async function Zo(n,o=!0){n.checkVersion("3.8.1"),await n.addParticleUpdater("size",()=>Promise.resolve(new Xo),o)}async function nn(n,o=!0){n.checkVersion("3.8.1"),await Uo(n,!1),await $o(n,!1),await Jo(n,!1),await po(n,!1),await Vo(n,!1),await ko(n,!1),await Bo(n,!1),await Yo(n,!1),await Zo(n,!1),await n.refresh(o)}export{nn as loadBasic};
